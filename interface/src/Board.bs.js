// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Js_null from "rescript/lib/es6/js_null.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as ChessJs from "chess.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ReactChessboard from "react-chessboard";

var Chessboard = {};

function move_to_text(move) {
  if (move.move.is_castle_k) {
    return "O-O";
  }
  if (move.move.is_castle_q) {
    return "O-O-O";
  }
  var match = move.move.piece;
  if (match.length !== 1) {
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "Board.res",
            16,
            4
          ],
          Error: new Error()
        };
  }
  var match$1 = match[0];
  var piece_text;
  switch (match$1) {
    case "Bishop" :
        piece_text = "B";
        break;
    case "King" :
        piece_text = "K";
        break;
    case "Knight" :
        piece_text = "N";
        break;
    case "Pawn" :
        piece_text = "";
        break;
    case "Queen" :
        piece_text = "Q";
        break;
    case "Rook" :
        piece_text = "R";
        break;
    default:
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "Board.res",
              16,
              4
            ],
            Error: new Error()
          };
  }
  var c = move.move.start_spec;
  var starting_annotation_text = c === null ? "" : Js_null.getExn(c);
  var sqr = move.move.target;
  var target_square_text;
  if (sqr !== undefined) {
    var sqr$1 = Caml_option.valFromOption(sqr);
    target_square_text = sqr$1.col + String(sqr$1.row);
  } else {
    target_square_text = "";
  }
  return piece_text + starting_annotation_text + target_square_text;
}

var Chess = {};

function Board(Props) {
  var lines = Props.lines;
  var nodes = Props.nodes;
  var transitions = Props.transitions;
  var line_select = Props.line_select;
  var onClick = Props.onClick;
  var line = Caml_array.get(lines, line_select);
  var from_node_idx = line.from_node;
  var find_nidx = function (node) {
    return Caml_obj.equal(node.node_id, from_node_idx);
  };
  var begin_node = Caml_array.get(nodes.filter(find_nidx), 0);
  var match = React.useState(function () {
        return begin_node.board_hash;
      });
  var setGame = match[1];
  var game = match[0];
  var match$1 = React.useState(function () {
        return 0;
      });
  var setLid = match$1[1];
  var lid = match$1[0];
  var match$2 = React.useState(function () {
        return false;
      });
  var setHasBeenMistaken = match$2[1];
  var match$3 = React.useState(function () {
        return "board-undefine";
      });
  var setCStatus = match$3[1];
  var find_tidx = function (transition) {
    return Caml_obj.equal(transition.transition_id, Caml_array.get(line.line, lid));
  };
  console.log(line);
  console.log([
        "LINE_ID",
        lid
      ]);
  var onDrop = function (sourceSquare, targetSquare) {
    var gameState = new ChessJs.Chess(game);
    var trans = Caml_array.get(transitions.filter(find_tidx), 0);
    var move_dict = {
      from: sourceSquare,
      to: targetSquare
    };
    var mp = gameState.get(sourceSquare);
    var mp_text;
    if (mp === null) {
      mp_text = "";
    } else {
      var pt = Js_null.getExn(mp).type;
      mp_text = pt === "p" ? "" : pt.toUpperCase();
    }
    var c = Js_string.slice(0, 1, sourceSquare);
    var r = Js_string.slice(1, 2, sourceSquare);
    console.log(trans.move);
    if (mp_text + c + targetSquare === move_to_text(trans.move) || mp_text + r + targetSquare === move_to_text(trans.move) || mp_text + targetSquare === move_to_text(trans.move)) {
      gameState.move(move_dict);
      Curry._1(setGame, (function (param) {
              return gameState.fen();
            }));
      Curry._1(setLid, (function (lid) {
              return lid + 1 | 0;
            }));
      return Curry._1(setCStatus, (function (param) {
                    return "board-correct";
                  }));
    } else {
      Curry._1(setCStatus, (function (param) {
              return "board-error";
            }));
      return Curry._1(setHasBeenMistaken, (function (param) {
                    return true;
                  }));
    }
  };
  if (lid >= line.line.length) {
    return React.createElement("div", undefined, React.createElement("button", {
                    className: "button-3",
                    onClick: onClick
                  }, "Next"));
  }
  var trans = Caml_array.get(transitions.filter(find_tidx), 0);
  var comment = trans.move.comment === null ? "" : Js_null.getExn(trans.move.comment);
  return React.createElement("div", undefined, React.createElement("div", {
                  className: "board-container " + match$3[0]
                }, React.createElement(ReactChessboard.Chessboard, {
                      position: game,
                      onPieceDrop: onDrop
                    })), React.createElement("div", {
                  className: "comment"
                }, comment));
}

var make = Board;

export {
  Chessboard ,
  move_to_text ,
  Chess ,
  make ,
}
/* react Not a pure module */
