(* Actually implement the parser *)

open Core

type side = White | Black;;

 type piece =
      Pawn (* indicate whether a pawn can be captured en passant *)
    | Knight
    | Bishop
    | Rook
    | Queen
    | King;; (* also indicate the avialability of castling either side *)

type square = {
    col: char;
    row: int;
};;

type mv = {
  piece: piece;
  target: square;
  is_check: bool;
  is_mate: bool;
  is_take: bool;
  is_castle_q: bool;
  is_castle_k: bool;
  promote: piece option; (* Could have no promotion *)
};;

(* We could potentially allow continuation in comments, but that involves more complex designs *)
type move = {
  side: side;
  move: mv;
  comment: string;
};;

type turn = {
  id: int;
  white_move: move option;
  black_move: move option;
};;

type conclusion = WhiteWin | BlackWin | Draw | Unknown;;

type move_sec = {
  turns: turn list;
  conclusion: conclusion;
};;

type tag = {
  symbol: string;
  content: string;
};;

type tag_sec = tag list;;

type pgn = tag_sec * move_sec;;

let parse_tag (content: char list) (agg: pgn): pgn * char list =
  (* parse a tag and then stop parsing *)
  let rec parse_symbol (ct: char list): (char list) * (char list) =
    match ct with
    | [] -> [], []
    | h::tl ->
      if (Char.(>=) h '0') && (Char.(<=) h '9') ||
         (Char.(>=) h 'a') && (Char.(<=) h 'z') ||
         (Char.(>=) h 'A') && (Char.(<=) h 'Z') ||
         (Char.(=) h '_') then
          match parse_symbol tl with
         | sym, remainder -> h::sym, remainder
      else if Char.(=) h ' ' then
        (* The parsing of symbol should end here *)
        [], tl
      else
        failwith "unknown character encountered!"
    in
  let rec parse_info (ct: char list): (char list) * (char list) =
    match ct with
    | [] -> [], []
    | h::tl ->
      if (Char.(=) h '"') then
        (* The parse should straight-up ends here *)
        [], tl
      else
        match parse_info tl with
        | info, remainder -> h::info, remainder
    in
  let rec parse_to_end_bracket (ct: char list): (char list) =
    match ct with
    | [] -> []
    | h::tl -> if Char.(=) h ']' then tl else parse_to_end_bracket tl
  in
  match parse_symbol content with
  | [], remainder -> agg, parse_to_end_bracket remainder
  | symbol_list, remainder -> begin
    let info_list, remainder = parse_info remainder in
    match agg with
    | tsec, msec -> let agg = (tsec @ [{symbol=(String.of_char_list symbol_list); content=(String.of_char_list info_list)}]), msec in
      agg, parse_to_end_bracket remainder
  end

let rec parse_turns (content: char list) (agg: pgn): pgn * (char list) =
  (* Parse the move list section *)
  let parse_conclusion (char_list: char list): conclusion * (char list) =
  ;;
  in
  let parse_turns_internal (char_list: char list): (turn list) * (char list) =
  ;;
  in
  match remainder with
  | [] -> agg, []
  | [c] -> if Char.(=) c '*' then
    begin
      match agg with tsec, msec ->
        (tsec, {turns=msec.turns; conclusion=Unknown}), []
    end
    else
      agg, [] (* Maybe returned the unparsed character? but single character cannot be parsed otherwise *)
  | h::f::tl -> 
      match agg with tsec, msec -> begin
      if Char.(=) h ' ' || Char.(=) h '\t' || Char.(=) h '\n' || Char.(=) h '\r' then
        parse_turns (f::tl) agg
      else if Char.(=) f '-' then
        (* We should parse result *)
        let con, _ = parse_conclusion content in
          (tsec, {turns=msec.turns; conclusion=con}), []
      else
        (* We should parse turns, use a new recursive function to  *)
        let tns, remainder = parse_turns_internal content in
          parse_turns remainder (tsec, {turns=tns; conclusion=Unknown})
      end

(* parse the content text of a pgn file, since pgn files are generated by stable platforms, we assume they are in correct format *)
let rec parse_pgn_text (char_list: char list) (agg: pgn): pgn * (char list) =
  match char_list with
  | [] -> agg, []
  | h::tl ->
    match h with
    | '[' -> begin
      match parse_tag tl agg with
        agg, remainder -> parse_pgn_text remainder agg
      end
    | '1' -> begin
      match parse_turns (h::tl) agg with
        agg, remainder -> parse_pgn_text remainder agg
      end
    | _ -> begin
      match parse_pgn_text tl agg with
        agg, remainder -> parse_pgn_text remainder agg
      end